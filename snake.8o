# started 0950 2021-10-01

:alias snakex       v0
:alias snakey       v1  # must be exactly one register after snakex
:alias snake_buf_i  v2
:alias snake_len    v3
:alias direction    v4
:alias applex       v5
:alias appley       v6
:alias score        v7
:alias animctr      v8
:alias animctr2     v9
:alias temp1        va
:alias temp2        vb
:alias temp3        vc
:alias temp4        vd
:alias temp5        ve

:const NORTH   1
:const SOUTH   2
:const EAST    3
:const WEST    4

:const SPRITE_SIZE     7
:calc  SPRITE_SIZE_x2  { SPRITE_SIZE * 2 }
:calc  LIMIT_X         { 128 }
:calc  LIMIT_Y         {  64 }
:calc  SNAKE_START_X   { SPRITE_SIZE }
:calc  SNAKE_START_Y   { SPRITE_SIZE }
:const SNAKE_MAX_SZ    24
:const SNAKE_BUF       100

: main
	hires
	init

	loop
		read-input
		step-snake
		step-anims

		check-snake
		if temp1 == 1 begin
			gameover
			init
		end
		if temp1 == 2 begin
			animctr := 20
			snake_len += 1

			draw-apple
			place-apple
			draw-apple
		end
	again
;

: init
	plane 3
	clear
	snakex := SNAKE_START_X
	snakey := SNAKE_START_Y
	snake_buf_i := 0
	snake_len := 2
	direction := EAST
	score := 0
	draw-score
	place-apple
	draw-apple
;

: step-anims
	# note: snake face animations are done in step-snake

	if animctr > 0 begin
		if animctr > 10 begin
			if animctr >= 16 begin
				draw-score
				score += 2
				draw-score
			end

			if animctr == 20 then draw-apple
			if animctr == 19 then draw-apple
			if animctr == 18 then draw-apple
			if animctr == 17 then draw-apple
		end

		animctr -= 1
	end

	vf := 1
	animctr2 -= vf
	if vf == 0 then animctr2 := 30
;

: read-input
	loop
		vf := OCTO_KEY_W
		if vf key then direction := NORTH

		vf := OCTO_KEY_A
		if vf key then direction := WEST

		vf := OCTO_KEY_S
		if vf key then direction := SOUTH

		vf := OCTO_KEY_D
		if vf key then direction := EAST

		vf := delay
		if vf != 0 then
	again

	vf := 0x07
	delay := vf
;

: step-snake
	plane 2

	# save old head
	i := SNAKE_BUF
	i += snake_buf_i
	save snakex - snakey

	snake_buf_i += 2
	temp1 := snake_len
	temp1 <<= temp1
	if snake_buf_i >= temp1 then snake_buf_i := 0

	# erase previous snake head, draw body
	i := snake-head
	if animctr2 == 19 then i := snake-body
	if animctr  == 19 then i := snake-yum
	if animctr  == 18 then i := snake-yum
	sprite snakex snakey SPRITE_SIZE
	i := snake-body
	sprite snakex snakey SPRITE_SIZE

	if direction == NORTH then snakey -= SPRITE_SIZE
	if direction == SOUTH then snakey += SPRITE_SIZE
	if direction == WEST  then snakex -= SPRITE_SIZE
	if direction == EAST  then snakex += SPRITE_SIZE

	# draw new snake head
	i := snake-head
	if animctr2 == 20 then i := snake-body
	if animctr  == 20 then i := snake-yum
	if animctr  == 19 then i := snake-yum
	sprite snakex snakey SPRITE_SIZE

	# get coord of last tail and erase.
	# (snake_buf_i currently points to the last tail
	# since we incremented it)
	#
	i := SNAKE_BUF
	i += snake_buf_i
	load temp1 - temp2
	i := snake-body
	sprite temp1 temp2 SPRITE_SIZE
;

: check-snake
	temp1 := 0
	if snakey >= LIMIT_Y then temp1 := 1
	if snakex >= LIMIT_X then temp1 := 1

	temp2 := 0
	loop
		i := SNAKE_BUF
		i += temp2
		load temp4 - temp5
		if temp4 == snakex begin
			if temp5 == snakey begin
				temp1 := 1
				jump brk-chk-loop
			end
		end

		temp2 += 2
		temp3 := snake_len
		temp3 <<= temp3
		if temp2 < temp3 then
	again
: brk-chk-loop

	if snakex == applex begin
		if snakey == appley then
			temp1 := 2
	end
;

: draw-score
	plane 1

	i := score-buf
	bcd score

	temp1 := 0
	temp2 := 0
	loop
		i := score-buf
		i += temp2
		load temp3 - temp3
		i := hex temp3

		temp3 := temp2
		temp3 <<= temp3
		vf := temp2
		temp3 += vf
		temp3 <<= temp3
		temp3 += 1

		vf := 123
		sprite vf temp3 5 
		temp2 += 1
		if temp2 < 3 then
	again
;

: place-apple
	applex := SPRITE_SIZE
	loop
		applex += SPRITE_SIZE
		if applex >= LIMIT_X then applex := SPRITE_SIZE
		temp1 := random 30
		if temp1 != 0 then
	again

	appley := SPRITE_SIZE
	loop
		appley += SPRITE_SIZE
		if appley >= LIMIT_Y then appley := SPRITE_SIZE
		temp1 := random 30
		if temp1 != 0 then
	again
;

: draw-apple
	plane 3
	temp1 := appley
	i := apple-body
	sprite applex temp1 SPRITE_SIZE

	plane 2
	vf := SPRITE_SIZE
	temp1 -= vf
	i := apple-top
	sprite applex temp1 SPRITE_SIZE
;

: gameover
	draw-gameover-message
	vf := key
	draw-gameover-message
;

: draw-gameover-message
	:const GAMEOVER_MSG_LEN 8
	:calc GAMEOVER_MSG_Y { (  64 / 2 ) - ( SPRITE_SIZE / 2 ) }
	:calc GAMEOVER_MSG_X { ( 128 / 2 ) - ( ( GAMEOVER_MSG_LEN / 2 ) * SPRITE_SIZE ) }

	plane 1

	i := gameover-text
	temp1 := GAMEOVER_MSG_LEN
	temp2 := GAMEOVER_MSG_X
	temp3 := GAMEOVER_MSG_Y
	loop
		sprite temp2 temp3 SPRITE_SIZE
		temp2 += SPRITE_SIZE
		vf := SPRITE_SIZE
		i += vf
		temp1 -= 1
		if temp1 > 0 then
	again
;

: apple-top
	0x00 0x00 0x00 0x06 0x4E 0x2C 0x00
: apple-body
	0x7C 0xFE 0xFE 0xFE 0xFE 0xFE 0x7C
	0x7C 0xDE 0xBE 0xFE 0xFE 0xFE 0x7C
: snake-head
	0x7C 0xFE 0xFE 0xBA 0xFE 0xFE 0x7C
: snake-body
	0x7C 0xFE 0xFE 0xFE 0xFE 0xFE 0x7C
: snake-yum
	0x7C 0xFE 0xBA 0x54 0xFE 0xFE 0x7C
: gameover-text
	0x78 0x84 0x80 0x9C 0x84 0x78 0x00 # G
	0x78 0x84 0x84 0xFC 0x84 0x84 0x00 # A
	0x84 0xCC 0xB4 0x84 0x84 0x84 0x00 # M
	0x7C 0x80 0xF8 0x80 0x80 0x7C 0x00 # E
	0x78 0x84 0x84 0x84 0x84 0x78 0x00 # O
	0x84 0x84 0x84 0x84 0x48 0x30 0x00 # V
	0x7C 0x80 0xF8 0x80 0x80 0x7C 0x00 # E
	0xF8 0x84 0x84 0xF8 0x84 0x84 0x00 # R
: score-buf
